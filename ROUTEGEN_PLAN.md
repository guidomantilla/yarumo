# RouteGen – Plan de Diseño y Generación de Rutas para Gin

## Objetivo

Construir una herramienta de **code generation** para Go que, a partir de métodos de un `struct` anotados con:

```go
// @route METHOD /path
func (h *handlers) SomeMethod(c *gin.Context) {}
```

genere automáticamente un archivo Go con **funciones de definición de rutas**, una por handler, con la firma:

```go
func Route_POST_events(h *handlers) (string, string, gin.HandlerFunc) {
    return "POST", "/events", h.SomeMethod
}
```

En esta fase el generador **no registra rutas en Gin**. Solo produce definiciones reutilizables.

---

## Alcance (scope)

Incluye:
- Parsing de código Go (AST)
- Lectura de anotaciones `@route`
- Validación de firmas y duplicados
- Generación de código Go formateado
- Instalación vía `go install`
- Integración con `go:generate`

No incluye:
- Middlewares
- Runtime reflection para comentarios
- Registro automático de rutas (router.Handle)
- Inferencia de rutas por convención de nombres
- Modificación de código fuente existente

---

## Contrato de Entrada

### Código de usuario esperado

```go
type handlers struct {
    repository Repository
}

// @route POST /events
func (h *handlers) SomeRandomeMethodName(c *gin.Context) {}

// @route GET /events/:id
func (h *handlers) GetEvents(c *gin.Context) {}
```

### Reglas de entrada

- El receiver debe ser un tipo objetivo (ej. `*handlers`) indicado por configuración (`--type`).
- La firma del método debe ser exactamente:
  ```go
  func(*gin.Context)
  ```
  (1 parámetro, 0 retornos).
- El comentario debe contener una línea con el formato:
  ```
  @route METHOD PATH
  ```
- Métodos sin `@route` se ignoran.
- Si existen rutas duplicadas por pareja `(METHOD, PATH)` → error.

---

## Contrato de Salida

### Archivo generado

Ejemplo: `zz_routes_gen.go`

```go
// Code generated by routegen; DO NOT EDIT.

package core

import "github.com/gin-gonic/gin"

func Route_POST_events(h *handlers) (string, string, gin.HandlerFunc) {
    return "POST", "/events", h.SomeRandomeMethodName
}

func Route_GET_events_id(h *handlers) (string, string, gin.HandlerFunc) {
    return "GET", "/events/:id", h.GetEvents
}
```

### Propiedades del archivo generado

- **Determinista**: mismas entradas → misma salida.
- **Formateado**: `go/format` aplicado.
- **Errores tempranos**: fallar en generación si hay inconsistencias.

---

## Convención de nombres de funciones generadas

Formato:

```
Route_<METHOD>_<sanitized_path>
```

### Reglas de sanitización del `PATH`

- Remover `/` inicial.
- Reemplazar:
  - `/` → `_`
  - `:` → `_`
  - `{` y `}` → `_`
- Colapsar múltiples `_`.
- Si queda vacío → `root`.
- Si el resultado no es un identificador Go válido (por ejemplo, empieza con dígito), anteponer `p_`.

Ejemplos:

| METHOD | PATH            | FuncName               |
|-------:|-----------------|------------------------|
| POST   | /events         | Route_POST_events      |
| GET    | /events/:id     | Route_GET_events_id    |
| GET    | /               | Route_GET_root         |
| GET    | /v1/users/{id}  | Route_GET_v1_users_id  |

### Colisiones

Si dos rutas producen el mismo `FuncName` tras sanitizar:
- Agregar sufijo determinista:
  - opción A: contador (`_2`, `_3`, …) según orden estable
  - opción B: hash corto del `(METHOD,PATH)` (ej. `_A1B2`)
- Por ahora: **contador** es suficiente y simple.

---

## Instalación y ejecución

### Instalación (recomendada, estable)

```bash
go install github.com/<org>/routegen/cmd/routegen@latest
```

(ideal fijar versión para builds reproducibles).

### Uso con `go:generate`

En el paquete donde vive `handlers`:

```go
//go:generate routegen --type handlers --dir . --out zz_routes_gen.go
```

Ejecutar:

```bash
go generate ./...
```

### Flags del CLI

- `--dir` (default `.`): directorio del paquete a analizar
- `--type` (requerido): nombre del tipo receiver objetivo (`handlers`)
- `--out` (default `zz_routes_gen.go`): archivo a generar
- `--func-prefix` (default `Route_`): prefijo de funciones generadas (opcional)

---

## Arquitectura interna

### Componentes principales

1) **Reader (Lector de código)**  
2) **Generator (Generador de código)**  
3) **CLI (Orquestador)**

### Estructura sugerida del repositorio

```
/cmd/routegen/main.go
/internal/routegen/reader/
  discover.go
  parse.go
  inspect.go
  annotations.go
  validate.go
/internal/routegen/generator/
  namer.go
  model.go
  emit.go
  format.go
/internal/routegen/shared/
  types.go
  errors.go
```

---

## Reader (Lector de código)

Responsabilidad: convertir el paquete Go en un modelo de rutas (`RouteModel`).

### Subcomponentes

#### 1. SourceDiscoverer
- Encuentra archivos `.go` dentro de `--dir`.
- Excluye:
  - `*_test.go`
  - `vendor/`
  - (opcional) `cmd/` si se desea.

**Entrada**: `packageDir string`  
**Salida**: `[]string` (paths)

#### 2. ASTParser
- Parse de cada archivo con comentarios:
  - `parser.ParseFile(fset, filename, nil, parser.ParseComments)`

**Salida**: `[]*ast.File` + `*token.FileSet`

#### 3. TypeInspector
- Recorre `ast.File.Decls`, filtra `*ast.FuncDecl` con `Recv != nil`.
- Identifica receiver `handlers` o `*handlers` según `--type`.
- Valida firma del método:
  - 1 parámetro
  - tipo exacto `*gin.Context`
  - 0 resultados

> Validación robusta de `*gin.Context`: en AST puede aparecer como `*ast.SelectorExpr` (`gin.Context`) con `StarExpr`. Se compara por estructura del AST, o usando `go/types` si se prefiere.

**Salida**: `[]MethodNode`  
Campos: `Name`, `DocText`, `Pos`, `FileName`.

#### 4. RouteAnnotationParser
- Extrae la primera línea que contenga `@route`.
- Formato esperado: `@route METHOD PATH`
- Valida:
  - `METHOD` ∈ {GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS}
  - `PATH` inicia con `/`

**Salida**: `[]RouteDef`  
Campos: `HTTPMethod`, `Path`, `HandlerMethodName`, `Pos`.

#### 5. RouteModelValidator
- Verifica duplicados `(HTTPMethod, Path)` → error.
- Verifica que `HandlerMethodName` existe (ya garantizado por inspector).
- Opcional: warning si no hay rutas.

**Salida**: `RouteModel`

---

## Generator (Generador de código)

Responsabilidad: transformar `RouteModel` en un archivo Go con funciones.

### Subcomponentes

#### 1. TemplateModelBuilder
- Orden estable de rutas:
  - preferible por posición (`token.Pos`) para reproducibilidad.
- Construye `GenModel` con rutas ordenadas y nombres generados.

#### 2. RouteFunctionNamer (`namer.go`)
- Implementa sanitización de `PATH`.
- Produce `FuncName` determinista.

#### 3. CodeEmitter (`emit.go`)
- Emite:
  - header “Code generated…”
  - `package <pkg>`
  - `import "github.com/gin-gonic/gin"`
  - N funciones, una por ruta:
    ```go
    func <FuncName>(h *<TypeName>) (string, string, gin.HandlerFunc) {
        return "<METHOD>", "<PATH>", h.<HandlerMethodName>
    }
    ```

#### 4. Formatter (`format.go`)
- Aplica `go/format`.
- (opcional) `imports.Process` si se desea controlar imports automáticamente.

---

## CLI (cmd/routegen)

Responsabilidad: orquestar Reader + Generator.

### Flujo

1. Parse flags (`--dir`, `--type`, `--out`).
2. Ejecutar Reader:
   - discover → parse → inspect → parse annotations → validate.
3. Ejecutar Generator:
   - build model → emit → format.
4. Escribir archivo en `--out` dentro de `--dir`.

### Códigos de salida
- `0`: ok
- `1`: error de parsing/validación/generación

---

## Criterios de aceptación

- Si un método tiene `// @route POST /events`, se genera una función con:
  - retorno `"POST"`, `"/events"`, `h.<method>`
- Métodos sin `@route` no generan salida.
- Si la firma no es `func(*gin.Context)` → error claro.
- Si hay duplicados `(METHOD, PATH)` → error claro.
- El archivo generado compila en el paquete donde se genera.

---

## Notas futuras (fuera de scope por ahora)

- Generar adicionalmente un registrador (opt-in):
  - `func RegisterRoutes(r gin.IRoutes, h *handlers)`
- Soportar grupos (`/v1`).
- Soportar middlewares por anotación.
- Soportar múltiples tipos receiver.
